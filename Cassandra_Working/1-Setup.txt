#Kubectl and Minikube
--Install dependencies:

sudo apt update && sudo apt upgrade -y
sudo apt install curl apt-transport-https -y

--Install kubectl
sudo snap install kubectl --classic

kubectl version --client

curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
rm minikube-linux-amd64

sudo apt install docker.io
sudo usermod -aG docker $USER && newgrp docke
minikube start --memory=8192 --cpus=4

kubectl get nodes

----------------
Helm
sudo snap install helm --classic

----------------
K8ssandra

helm repo add jetstack https://charts.jetstack.io
helm repo update
helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version v1.13.2 --set installCRDs=true

helm repo add k8ssandra https://helm.k8ssandra.io/
helm repo update
helm install k8ssandra-operator k8ssandra/k8ssandra-operator --namespace k8ssandra-operator --create-namespace


--once operator is running
k8ssandraCluster YAML
apiVersion: k8ssandra.io/v1alpha1
kind: K8ssandraCluster
metadata:
  name: k8ssandra-example
spec:
  cassandra:
    version: 4.0.11 # Specify a supported Cassandra version
    datacenter:
      name: dc1
      racks:
        - name: default
      size: 3 # Number of Cassandra nodes
      storageConfig:
        cassandraDataVolume:
          storageClassName: standard # Use your cluster's appropriate storage class
          size: 10Gi
      config:
        # Optional: You can specify additional cassandra.yaml properties here
        # num_tokens: 256
  # Optional: Include other components like Stargate, Reaper, Medusa
  # stargate:
  #   size: 1
  #   replicas: 1

or

apiVersion: k8ssandra.io/v1alpha1
kind: K8ssandraCluster
metadata:
  name: k8ssandra
  namespace: k8ssandra-operator
spec:
  cassandra:
    serverVersion: "4.1.3"
    datacenters:
      - metadata:
          name: dc1
        size: 1
        storageConfig:
          cassandraDataVolumeClaimSpec:
            accessModes: ["ReadWriteOnce"]
            resources:
              requests:
                storage: 5Gi
        config:
          cassandraYaml:
            authenticator: PasswordAuthenticator

or

apiVersion: k8ssandra.io/v1alpha1
kind: K8ssandraCluster
metadata:
  name: k8ssandra
  namespace: k8ssandra-operator
spec:
  cassandra:
    clusterName: dc1
    datacenters:
      - metadata:
          name: dc1
        size: 1
        config:
          cassandraYaml:
            authenticator: PasswordAuthenticator
            authorizer: CassandraAuthorizer
          jvmOptions:
            heapSize: 512M
            heapNewGenSize: 256M
        podTemplateSpec:
          spec:
            containers:
              - name: cassandra
                resources:
                  limits:
                    memory: "2Gi"
                  requests:
                    memory: "1Gi"


kubectl apply -f k8ssandraCluster.yaml -n k8ssandra-operator

kubectl get k8ssandracluster -n k8ssandra-operator

========================================================================
K8ssandra Works Internally:

> Install via Helm
  You deploy K8ssandra with a single Helm chart

helm repo add k8ssandra https://helm.k8ssandra.io/
helm install my-k8s k8ssandra/k8ssandra

> Operator Launch

  The Helm chart installs:
  - cass-operator
  - Stargate
  - Reaper
  - Medusa
  - Monitoring stack

> cass-operator Creates Cassandra Cluster

  The operator creates:

  - StatefulSet for each Cassandra rack
  - PersistentVolumeClaims for data
  - Services for gossip, CQL, and JMX

  It ensures:
    --Seed nodes are configured
    --Nodes join the ring correctly
    --Rolling upgrades happen safely

> Services Layer Starts (Stargate)

  Stargate nodes connect to Cassandra and provide easy-to-use APIs.

> Automated Ops Kick In

  Reaper sets up scheduled repairs
  Prometheus begins scraping metrics
  Medusa configures backup schedules
  K8ssandra now runs and maintains itself with minimal intervention.

> Multi-Datacenter and Multi-Region Support

  K8ssandra supports:

  Multi-DC Cassandra clusters
  Topologies across AZs or cloud regions
  Automated rack awareness

  This is especially useful for production-grade, globally distributed deployments.

Benefits of Using K8ssandra

-- Fully automated Cassandra on Kubernetes
-- Developer-friendly APIs via Stargate
-- Easy scaling using kubectl
-- Automated repairs and backups
-- Cloud-agnostic (EKS, AKS, GKE, on-prem, etc.)
-- Production-ready right out of the box

--------------------------------------





